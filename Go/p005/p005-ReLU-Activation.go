package main

import (
	"fmt"
	"math/rand"
	"p005/nnfs"

	"gonum.org/v1/gonum/mat"
)

// LayerDense represents a layer
type LayerDense struct {
	Weights *mat.Dense
	Biases  *mat.Dense
	Output  *mat.Dense
}

// NewLayerDense creates layer generated by random numbers based on given number of inputs and neurons
func NewLayerDense(numberOfInputs, numberOfNeurons int) *LayerDense {
	randData := make([]float64, numberOfInputs*numberOfNeurons)
	for i := range randData {
		randData[i] = 0.10 * rand.NormFloat64()
	}
	return &LayerDense{
		Weights: mat.NewDense(numberOfInputs, numberOfNeurons, randData),
		Biases:  mat.NewDense(1, numberOfNeurons, nil),
	}
}

// Forward forwards the input
func (l *LayerDense) Forward(input *mat.Dense) {
	var mulRes mat.Dense
	mulRes.Mul(input, l.Weights)
	l.Output = mat.NewDense(mulRes.RawMatrix().Rows, mulRes.RawMatrix().Cols, nil)
	for i := 0; i < mulRes.RawMatrix().Rows; i++ {
		for j := 0; j < mulRes.RawMatrix().Cols; j++ {
			output := mulRes.At(i, j) + l.Biases.At(0, j)
			l.Output.Set(i, j, output)
		}
	}
}

// ActivationRelu represents the ReLU activation function result
type ActivationRelu struct {
	Output *mat.Dense
}

// NewActivationRelu returns ActivationRelu with nil Output
func NewActivationRelu() *ActivationRelu {
	return &ActivationRelu{}
}

// Forward forwards the activation result
func (a *ActivationRelu) Forward(input *mat.Dense) {
	a.Output = mat.NewDense(input.RawMatrix().Rows, input.RawMatrix().Cols, nil)
	for i := 0; i < input.RawMatrix().Rows; i++ {
		for j := 0; j < input.RawMatrix().Cols; j++ {
			x := input.At(i, j)
			if x > 0 {
				a.Output.Set(i, j, x)
			} else {
				a.Output.Set(i, j, 0)
			}
		}
	}
}

func main() {
	rand.Seed(0)
	X, _ := nnfs.NewSpiralData(100, 3)

	layer1 := NewLayerDense(2, 5)
	activation1 := NewActivationRelu()

	layer1.Forward(X)
	// fmt.Println(layer1.Output)
	activation1.Forward(layer1.Output)
	fmt.Println(activation1.Output)
}
