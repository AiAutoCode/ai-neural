package main

import (
	"fmt"
	"math"
	"math/rand"
	"p005/nnfs"

	"gonum.org/v1/gonum/mat"
	"gonum.org/v1/plot"
	"gonum.org/v1/plot/plotter"
	"gonum.org/v1/plot/plotutil"
	"gonum.org/v1/plot/vg"
)

// LayerDense represents a layer
type LayerDense struct {
	Weights *mat.Dense
	Biases  *mat.Dense
	Output  *mat.Dense
}

// NewLayerDense creates layer generated by random numbers based on given number of inputs and neurons
func NewLayerDense(numberOfInputs, numberOfNeurons int) *LayerDense {
	randData := make([]float64, numberOfInputs*numberOfNeurons)
	for i := range randData {
		randData[i] = 0.10 * rand.NormFloat64()
	}
	return &LayerDense{
		Weights: mat.NewDense(numberOfInputs, numberOfNeurons, randData),
		Biases:  mat.NewDense(1, numberOfNeurons, nil),
	}
}

// Forward forwards the input
func (l *LayerDense) Forward(input *mat.Dense) {
	var mulRes mat.Dense
	mulRes.Mul(input, l.Weights)
	l.Output = mat.NewDense(mulRes.RawMatrix().Rows, mulRes.RawMatrix().Cols, nil)
	for i := 0; i < mulRes.RawMatrix().Rows; i++ {
		for j := 0; j < mulRes.RawMatrix().Cols; j++ {
			output := mulRes.At(i, j) + l.Biases.At(0, j)
			l.Output.Set(i, j, output)
		}
	}
}

// ActivationRelu represents the ReLU activation function result
type ActivationRelu struct {
	Output *mat.Dense
}

// NewActivationRelu returns ActivationRelu with nil Output
func NewActivationRelu() *ActivationRelu {
	return &ActivationRelu{}
}

// Forward forwards the activation result
func (a *ActivationRelu) Forward(input *mat.Dense) {
	a.Output = mat.NewDense(input.RawMatrix().Rows, input.RawMatrix().Cols, nil)
	for i := 0; i < input.RawMatrix().Rows; i++ {
		for j := 0; j < input.RawMatrix().Cols; j++ {
			x := input.At(i, j)
			if x > 0 {
				a.Output.Set(i, j, x)
			} else {
				a.Output.Set(i, j, 0)
			}
		}
	}
}

func main() {
	rand.Seed(0)
	X, y := nnfs.NewSpiralData(100, 3)

	plotSpiral(X, y)

	layer1 := NewLayerDense(2, 5)
	activation1 := NewActivationRelu()

	layer1.Forward(X)
	// fmt.Println(layer1.Output)
	activation1.Forward(layer1.Output)
	fmt.Println(activation1.Output)
}

func plotSpiral(X *mat.Dense, y *mat.Dense) {
	p, _ := plot.New()

	p.Title.Text = "Spiral"
	p.X.Label.Text = "X"
	p.Y.Label.Text = "Y"

	c1 := make(plotter.XYs, 0)
	c2 := make(plotter.XYs, 0)
	c3 := make(plotter.XYs, 0)
	for i := 0; i < X.RawMatrix().Rows; i++ {
		if y.At(i, 0) == 0 {
			c1 = append(c1, plotter.XY{
				X: X.At(i, 0),
				Y: X.At(i, 1),
			})
		} else if y.At(i, 0) == 1 {
			c2 = append(c2, plotter.XY{
				X: X.At(i, 0),
				Y: X.At(i, 1),
			})
		} else if y.At(i, 0) == 2 {
			c3 = append(c3, plotter.XY{
				X: X.At(i, 0),
				Y: X.At(i, 1),
			})
		}
	}

	_ = plotutil.AddLinePoints(p, "0", c1, "1", c2, "2", c3)

	if err := p.Save(4*vg.Inch, 4*vg.Inch, "points.png"); err != nil {
		panic(err)
	}
}

// NewSpiralData generates spiral data. see: https://cs231n.github.io/neural-networks-case-study/
func NewSpiralData(numberOfPoints, numberOfClasses int) (*mat.Dense, *mat.Dense) {
	X := mat.NewDense(numberOfPoints*numberOfClasses, 2, nil)
	y := mat.NewDense(numberOfPoints*numberOfClasses, 1, nil)

	for c := 0; c < numberOfClasses; c++ {
		radius := linspace(0, 1, numberOfPoints)
		t := linspace(float64(c*4), float64((c+1)*4), numberOfPoints)
		for i := range t {
			t[i] += 0.2 * rand.NormFloat64()
		}
		for i := 0; i < numberOfPoints; i++ {
			X.Set(c*numberOfPoints+i, 0, radius[i]*math.Sin(t[i]*2.5))
			X.Set(c*numberOfPoints+i, 1, radius[i]*math.Cos(t[i]*2.5))
			y.Set(c*numberOfPoints+i, 0, float64(c))
		}
	}

	return X, y
}

func linspace(start, end float64, num int) []float64 {
	result := make([]float64, num)
	step := (end - start) / float64(num-1)
	for i := range result {
		result[i] = start + float64(i)*step
	}
	return result
}
